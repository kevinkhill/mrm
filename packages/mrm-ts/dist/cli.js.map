{"version":3,"sources":["../src/cli.ts","../src/constants.ts","../src/lib/config.ts","../src/lib/utils.ts","../src/lib/promises.ts","../src/lib/errors.ts","../src/lib/npm.ts","../src/lib/npxResolver.ts","../src/lib/resolveDirectories.ts","../src/lib/taskCollector.ts","../src/lib/taskRunner.ts","../src/TaskStore.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport kleur from \"kleur\";\nimport { random } from \"middleearth-names\";\nimport minimist from \"minimist\";\nimport updateNotifier from \"update-notifier\";\n\nimport packageJson from \"../package.json\";\nimport { CONFIG_FILENAME, EXAMPLES, PREFIX } from \"./constants\";\nimport {\n\tgetConfig,\n\tisInvalidTaskError,\n\tisUndefinedOptionError,\n\tisUnknownAliasError,\n\tisUnknownTaskError,\n\tlongest,\n\tmrmDebug,\n\tprintError,\n\ttoNaturalList,\n} from \"./lib\";\nimport { TaskStore } from \"./TaskStore\";\nimport type { CliArgs, TaskRecords } from \"./types/mrm\";\n\nconst cliDebug = mrmDebug.extend(\"CLI\");\n\nlet loadingDotsInterval: NodeJS.Timer;\n\n/**\n * mrm, the cli tool\n */\nexport async function mrm() {\n\tconst debug = cliDebug;\n\tconst argv = minimist(process.argv.slice(2), {\n\t\talias: {\n\t\t\ti: \"interactive\",\n\t\t},\n\t\tboolean: [\"silent\", \"dump\", \"dry-run\", \"examine\", \"useNewTaskSignature\"],\n\t}) as CliArgs;\n\n\tdebug(\"argv: %O\", argv);\n\n\t// Create a new instance of the TaskStore and initialize it.\n\tconst MrmTasks = new TaskStore(argv);\n\n\t// Collect positional args as tasks to run\n\tconst tasks = argv._;\n\n\t// How are we executing\n\tconst binaryPath = process.env._;\n\tconst binaryName =\n\t\tbinaryPath && binaryPath.endsWith(\"/npx\") ? \"npx mrm\" : \"mrm\";\n\n\t// Preset\n\tconst preset = argv.preset || \"default\";\n\n\t// Show shome loading dots while we wait.\n\tif (!mrmDebug.enabled && !argv.silent) {\n\t\tprocess.stdout.write(`${PREFIX} Fetching the default preset`);\n\t\tloadingDotsInterval = setInterval(() => {\n\t\t\tprocess.stdout.write(\".\");\n\t\t}, 1000);\n\t}\n\n\tawait MrmTasks.initStore();\n\n\t// Gather options from the directories\n\tconst options = await getConfig(MrmTasks.PATH, argv);\n\tdebug(\"options: %O\", options);\n\n\tMrmTasks.mergeOptions(options);\n\n\t// Now that we are loaded, kill the dots timer.\n\tif (!mrmDebug.enabled && !argv.silent) {\n\t\tclearInterval(loadingDotsInterval);\n\t\tconsole.log(kleur.green(\"done\"));\n\t}\n\n\tif (argv[\"dump\"]) {\n\t\tconsole.log(\"\\n\", kleur.yellow().underline(\"Options\"), \"\\n\");\n\t\tconsole.log(MrmTasks);\n\t\treturn;\n\t}\n\n\t/**\n\t * If called with no tasks, `help` as a \"task\", or `--help`\n\t * show the mrm usage console output and exit.\n\t */\n\tif (tasks.length === 0 || tasks[0] === \"help\") {\n\t\tif (!argv.silent) {\n\t\t\tconsole.log(PREFIX, kleur.yellow(\"No tasks to run\"));\n\t\t}\n\n\t\t// Gather all the tasks from the directories\n\t\tcommandHelp(binaryName, await MrmTasks.getAllTasks());\n\t\treturn;\n\t}\n\n\t// Let's run some tasks!\n\ttry {\n\t\tawait MrmTasks.run(tasks);\n\t} catch (err: unknown) {\n\t\tif (isUnknownAliasError(err)) {\n\t\t\tprintError(err.message);\n\t\t} else if (isUnknownTaskError(err)) {\n\t\t\tconst { taskName } = err.extra;\n\n\t\t\tif (MrmTasks.isDefaultPreset) {\n\t\t\t\tconst modules = MrmTasks.PATH.slice(0, -1)\n\t\t\t\t\t.map(d => `${d}/${taskName}/index.js`)\n\t\t\t\t\t.concat([\n\t\t\t\t\t\t`\"${taskName}\" in the default mrm tasks`,\n\t\t\t\t\t\t`mrm-task-${taskName} package in local node_modules`,\n\t\t\t\t\t\t`${taskName} package in local node_modules`,\n\t\t\t\t\t\t`mrm-task-${taskName} package on the npm registry`,\n\t\t\t\t\t\t`${taskName} package on the npm registry`,\n\t\t\t\t\t]);\n\t\t\t\tprintError(`${err.message}\n\nWe've tried these locations:\n\n- ${modules.join(\"\\n- \")}`);\n\t\t\t} else {\n\t\t\t\tprintError(`Task \"${taskName}\" not found in the \"${preset}\" preset.\n\nNote that when a preset is specified no default search locations are used.`);\n\t\t\t}\n\t\t} else if (isInvalidTaskError(err)) {\n\t\t\tprintError(`${err.message}\n\nMake sure your task module exports a function.`);\n\t\t} else if (isUndefinedOptionError(err)) {\n\t\t\tconst { unknown } = err.extra;\n\t\t\tconst values = unknown.map(name => [name, random()]);\n\t\t\tconst configList = toNaturalList(unknown);\n\t\t\tconst heading = `Required config options are missed: ${configList}.`;\n\t\t\tconst cliHelp = `  ${binaryName} ${tasks.join(\" \")} ${values\n\t\t\t\t.map(([n, v]) => `--config:${n} \"${v}\"`)\n\t\t\t\t.join(\" \")}`;\n\n\t\t\tif (MrmTasks.isDefaultPreset) {\n\t\t\t\tconst userDirectories = MrmTasks.PATH.slice(0, -1);\n\n\t\t\t\tprintError(`${heading}\n\n1. Create a \"${CONFIG_FILENAME}\" file:\n\n{\n${values.map(([n, v]) => `  \"${n}\": \"${v}\"`).join(\",\\n\")}\n}\n\nIn one of these folders:\n\n- ${userDirectories.join(\"\\n- \")}\n\n2. Or pass options via command line:\n\n${cliHelp}\n\t`);\n\t\t\t} else {\n\t\t\t\tprintError(`${heading}\n\nYou can pass the option via command line:\n\n${cliHelp}\n\nNote that when a preset is specified no default search locations are used.`);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\n/**\n * Build and output for the command help for `mrm`\n */\nfunction commandHelp(binaryName: string, allTasks: TaskRecords) {\n\tconsole.log(\"\\n\");\n\tconsole.log(\n\t\t[\n\t\t\tkleur.underline(\"Usage\"),\n\t\t\tgetUsage(binaryName, EXAMPLES),\n\t\t\tkleur.underline(\"Available tasks\"),\n\t\t\tbuildTasksList(allTasks),\n\t\t].join(\"\\n\\n\")\n\t);\n\tconsole.log(\"\\n\");\n}\n\n/**\n * Get a pretty printed explanation of how to use `mrm`\n */\nfunction getUsage(binaryName: string, examples: string[][]): string {\n\tconst commands = examples.map(x => x.join(\"\"));\n\tconst commandsWidth = longest(commands).length;\n\n\treturn examples\n\t\t.map(([command, opts, description]) =>\n\t\t\t[\n\t\t\t\t\"   \",\n\t\t\t\tkleur.bold(binaryName),\n\t\t\t\tkleur.cyan(command),\n\t\t\t\tkleur.yellow(opts),\n\t\t\t\t\"\".padEnd(commandsWidth - (command + opts).length),\n\t\t\t\tdescription && `# ${description}`,\n\t\t\t].join(\" \")\n\t\t)\n\t\t.join(\"\\n\");\n}\n\n/**\n * Build a list of all the tasks and how they run\n */\nfunction buildTasksList(allTasks: TaskRecords) {\n\tconst names = Object.keys(allTasks).sort();\n\tconst nameColWidth = names.length > 0 ? longest(names).length : 0;\n\n\treturn names\n\t\t.map(name => {\n\t\t\tconst description = Array.isArray(allTasks[name])\n\t\t\t\t? `Runs ${toNaturalList(allTasks[name])}`\n\t\t\t\t: allTasks[name];\n\t\t\treturn (\n\t\t\t\t\"    \" + kleur.cyan(name.padEnd(nameColWidth)) + \"  \" + description\n\t\t\t);\n\t\t})\n\t\t.join(\"\\n\");\n}\n\n/**\n * Catch unhandled errors potentially thrown by tasks?\n */\nprocess.on(\"unhandledRejection\", (err: Error) => {\n\t// if (String(err.constructor.name).startsWith('Mrm')) {\n\tcliDebug(\"ERROR\");\n\tcliDebug(err);\n\tprintError(err.message);\n\tprocess.exit(1);\n\t// } else {\n\t// \tthrow err;\n\t// }\n});\n\nconst notifier = updateNotifier({ pkg: packageJson });\ncliDebug(\"current pkg version: %s\", notifier.update?.current);\ncliDebug(\"latest pkg version: %s\", notifier.update?.latest);\n\nnotifier.notify();\nmrm();\n","import envPaths from \"env-paths\";\nimport kleur from \"kleur\";\n\nexport const NPX_RESOLVER_QUIET = true;\n\nexport const PREFIX = `[${kleur.cyan(\"mrm\")}]`;\n\n/**\n * Filename for mrm configuration\n */\nexport const CONFIG_FILENAME = \"config.json\";\n\n/**\n * Path to mrm's local task cache\n */\nexport const TASK_CACHE_DIR = envPaths(\"mrm\", { suffix: \"tasks\" }).cache;\n\n/**\n * CLI examples\n */\nexport const EXAMPLES = [\n\t[\"\", \"\", \"List of available tasks\"],\n\t[\"<task>\", \"\", \"Run a task or an alias\"],\n\t[\"<task>\", \"--dir ~/unicorn\", \"Custom config and tasks folder\"],\n\t[\"<task>\", \"--preset unicorn\", \"Load config and tasks from a preset\"],\n\t[\n\t\t\"<task>\",\n\t\t\"--config:foo coffee --config:bar pizza\",\n\t\t\"Override config options\",\n\t],\n];\n","import { readFile } from \"fs/promises\";\nimport kleur from \"kleur\";\n\nimport { CONFIG_FILENAME } from \"../constants\";\nimport type { CliArgs, MrmOptions } from \"../types/mrm\";\nimport { mrmDebug, tryFile } from \"./utils\";\n\nconst debug = mrmDebug.extend(\"ConfigLoader\");\n\n/**\n * Load the configuration from file and command line\n */\nexport async function getConfig(\n\tdirectories: string[],\n\targv: CliArgs\n): Promise<MrmOptions> {\n\tconst configFromFile = await getConfigFromFile(directories);\n\tdebug(\"loaded: %O\", configFromFile);\n\n\treturn {\n\t\t...configFromFile,\n\t\t...getConfigFromCommandLine(argv),\n\t} as MrmOptions;\n}\n\n/**\n * Find and load config file.\n */\nexport async function getConfigFromFile(\n\tdirectories: string[]\n): Promise<Partial<MrmOptions>> {\n\ttry {\n\t\tconst filepath = await tryFile(CONFIG_FILENAME, directories);\n\t\tdebug(\"found: %s\", kleur.green(filepath));\n\n\t\treturn JSON.parse(await readFile(filepath, \"utf8\"));\n\t} catch (err) {\n\t\treturn {};\n\t}\n}\n\n/**\n * Get config options from command line, passed as --config:foo bar.\n */\nexport function getConfigFromCommandLine(argv: CliArgs): Partial<MrmOptions> {\n\treturn Object.keys(argv)\n\t\t.filter(k => k.startsWith(\"config:\"))\n\t\t.reduce((options, key) => {\n\t\t\treturn {\n\t\t\t\t...options,\n\t\t\t\t[key.replace(/^config:/, \"\")]: argv[key],\n\t\t\t};\n\t\t}, {});\n}\n","import Debug from \"debug\";\nimport fs from \"fs\";\nimport kleur from \"kleur\";\nimport { lstatSync } from \"node:fs\";\nimport { lstat } from \"node:fs/promises\";\nimport path from \"node:path\";\n\nimport type { MrmOptions } from \"../types/mrm\";\nimport { promiseFirst } from \"./promises\";\n\nexport const mrmDebug = Debug(\"mrm\");\n\n/**\n * Find the longest string in an array\n */\nexport function longest(input: string[]): string {\n\treturn input.reduce((a, b) => (a.length > b.length ? a : b), \"\");\n}\n\n/**\n * Test if a path exists\n */\nexport async function isDir(dir: string): Promise<boolean> {\n\tconst stat = await lstat(path.resolve(dir));\n\treturn stat.isDirectory();\n}\n\n/**\n * Test if a path exists, synchronously\n */\nexport function isDirSync(dir: string): boolean {\n\tconst stat = lstatSync(path.resolve(dir));\n\treturn stat.isDirectory();\n}\n\n/**\n * Pretty Error messages\n */\nexport function printError(message: string) {\n\tconsole.log();\n\tconsole.error(kleur.bold().red(message));\n\tconsole.log();\n}\n\n/**\n * Get all aliases from the options\n */\nexport function getAllAliases(options: MrmOptions) {\n\treturn options?.aliases ?? {};\n}\n\n/**\n * Returns the correct `mrm-` prefixed package name\n */\nexport function getPackageName(\n\ttype: \"task\" | \"preset\",\n\tpackageName: string\n): string {\n\tconst [scopeOrTask, scopedTaskName] = packageName.split(\"/\");\n\treturn scopedTaskName\n\t\t? `${scopeOrTask}/mrm-${type}-${scopedTaskName}`\n\t\t: `mrm-${type}-${scopeOrTask}`;\n}\n\n/**\n * Turn a list of items into a natural, readable list\n *\n * Code adapted from `lisitify`\n * @link https://github.com/ljharb/listify\n */\nexport function toNaturalList(\n\tlist: string[],\n\tseparator = \", \",\n\tfinalWord = \"and\"\n): string {\n\tconst trimmed = list.filter(item => item.trim());\n\tconst head = trimmed.slice(0, -1).join(separator);\n\tconst tail = `${finalWord} ${trimmed[trimmed.length - 1]}`;\n\n\treturn [head, tail].join(separator);\n}\n\n/**\n * Try to load a file from a list of folders.\n */\nexport async function tryFile(\n\tfilename: string,\n\tdirectories: string[]\n): Promise<string> {\n\tconst debug = mrmDebug.extend(\"tryFile\");\n\tdebug(\"trying for %s\", kleur.cyan(filename));\n\n\ttry {\n\t\treturn promiseFirst(\n\t\t\tdirectories.map(dir => {\n\t\t\t\tconst filepath = path.resolve(dir, filename);\n\t\t\t\treturn async function (): Promise<string> {\n\t\t\t\t\tdebug(\"entering: %s\", kleur.yellow(dir));\n\t\t\t\t\tawait fs.promises.access(filepath);\n\t\t\t\t\tdebug(\" | %s\", kleur.green(filepath));\n\t\t\t\t\treturn filepath;\n\t\t\t\t};\n\t\t\t})\n\t\t);\n\t} catch (err) {\n\t\tthrow new Error(`File \"${filename}\" not found.`);\n\t}\n}\n","/**\n * Process an array of strings, feeding into a function, that resolves promises in series.\n *\n * @link https://stackoverflow.com/a/29906506\n */\nexport async function promiseSeries<T>(\n\tarray: string[],\n\tfn: (arrItem: string) => Promise<T>\n) {\n\tconst results = {} as Record<string, T>;\n\n\tfor (let i = 0; i < array.length; i++) {\n\t\tconst currItem = array[i];\n\t\tconst r = await fn(currItem);\n\n\t\tresults[currItem] = r;\n\t}\n\n\treturn results; // will be resolved value of promise\n}\n\n/**\n * Executes promise-returning thunks in series until one is resolved\n */\nexport async function promiseFirst<T>(\n\tthunks: Array<(() => Promise<T>) | (() => T)>,\n\terrors: Error[] = []\n): Promise<T> {\n\tif (thunks.length === 0) {\n\t\tthrow new Error(`None of the ${errors.length} thunks resolved.\n\n${errors.join(\"\\n\")}`);\n\t}\n\n\tconst [thunk, ...rest] = thunks;\n\ttry {\n\t\treturn await thunk();\n\t} catch (error) {\n\t\treturn promiseFirst(rest, [...errors, error as Error]);\n\t}\n}\n","interface ExtraRecordTaskName {\n\ttaskName: string | string[];\n}\n\ninterface ExtraRecordUnknown {\n\tunknown: string[];\n}\n\nexport class MrmBaseError extends Error {\n\tdeclare extra?: ExtraRecordTaskName | ExtraRecordUnknown;\n\tconstructor(message: string, extra?: MrmBaseError[\"extra\"]) {\n\t\tsuper(message);\n\t\tthis.name = this.constructor.name;\n\t\tthis.extra = extra;\n\t}\n}\n\nexport class MrmPathNotExist extends MrmBaseError {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\nexport class MrmUnknownAlias extends MrmBaseError {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\nexport class MrmUnknownTask extends MrmBaseError {\n\tdeclare extra: ExtraRecordTaskName;\n\tconstructor(message: string, extra?: ExtraRecordTaskName) {\n\t\tsuper(message);\n\t\tthis.name = this.constructor.name;\n\t\tif (extra) {\n\t\t\tthis.extra = extra;\n\t\t}\n\t}\n}\n\nexport class MrmInvalidTask extends MrmBaseError {\n\tconstructor(message: string, extra?: ExtraRecordTaskName) {\n\t\tsuper(message);\n\t\tthis.name = this.constructor.name;\n\t\tthis.extra = extra;\n\t}\n}\n\nexport class MrmUndefinedOption extends MrmBaseError {\n\tdeclare extra: ExtraRecordUnknown;\n\tconstructor(message: string, extra?: ExtraRecordUnknown) {\n\t\tsuper(message);\n\t\tthis.name = this.constructor.name;\n\t\tif (extra) {\n\t\t\tthis.extra = extra;\n\t\t}\n\t}\n}\n\n/**\n * Type guard for `MrmUnknownAlias`\n */\nexport function isUnknownAliasError(err: unknown): err is MrmUnknownAlias {\n\treturn (err as MrmBaseError).constructor === MrmUnknownAlias;\n}\n\n/**\n * Type guard for `MrmUnknownTask`\n */\nexport function isUnknownTaskError(err: unknown): err is MrmUnknownTask {\n\treturn (err as MrmBaseError).constructor === MrmUnknownTask;\n}\n\n/**\n * Type guard for `MrmInvalidTask`\n */\nexport function isInvalidTaskError(err: unknown): err is MrmInvalidTask {\n\treturn (err as MrmBaseError).constructor === MrmInvalidTask;\n}\n\n/**\n * Type guard for `MrmUndefinedOption`\n */\nexport function isUndefinedOptionError(\n\terr: unknown\n): err is MrmUndefinedOption {\n\treturn (err as MrmBaseError).constructor === MrmUndefinedOption;\n}\n","import kleur from \"kleur\";\nimport { spawn, SpawnOptionsWithoutStdio } from \"node:child_process\";\nimport { lstat } from \"node:fs/promises\";\nimport path from \"node:path\";\nimport which from \"which\";\n\nimport { mrmDebug } from \"./utils\";\n\nasync function npmAsync(\n\tcommand: string[],\n\toptions?: SpawnOptionsWithoutStdio\n): Promise<string> {\n\tconst npm = await which(\"npm\");\n\n\treturn new Promise((resolve, reject) => {\n\t\tlet data = \"\";\n\t\tlet error = \"\";\n\t\tconst process = spawn(npm, command, options);\n\t\tprocess.stdout.on(\"data\", stdout => (data += stdout.toString()));\n\t\tprocess.stderr.on(\"data\", stderr => (error += stderr.toString()));\n\t\tprocess.on(\"error\", err => reject(err));\n\t\tprocess.on(\"close\", code => {\n\t\t\tcode !== 0 ? reject(error) : resolve(data);\n\t\t\tprocess.stdin.end();\n\t\t});\n\t});\n}\n\n/**\n * Run an `npm` command in a directory\n */\nexport async function npmCommand(\n\tcommand: string[],\n\tcwd: string\n): Promise<string> {\n\tconst debug = mrmDebug.extend(\"npmCommand\");\n\n\tdebug(\"entering: %s\", cwd);\n\tdebug(\"command: %s\", command);\n\n\treturn await npmAsync(command, { cwd });\n}\n\n/**\n * Install a package with `npm`\n */\nexport async function installWithNpm(\n\tpkgSpec: string,\n\tcwd: string\n): Promise<string> {\n\tconst debug = mrmDebug.extend(\"npmInstaller\");\n\tconst resolvedDir = path.resolve(cwd);\n\n\tconst stat = await lstat(resolvedDir);\n\tif (!stat.isDirectory()) {\n\t\tthrow new Error(`\"${cwd}\" did not resolve to a directory.`);\n\t}\n\n\tdebug(\"entering: %s\", kleur.yellow(resolvedDir));\n\n\ttry {\n\t\tconst stdout = await npmAsync([\"install\", pkgSpec], { cwd });\n\t\tdebug(stdout);\n\t\treturn resolvedDir;\n\t} catch (_) {\n\t\tthrow new Error(`Directory \"${resolvedDir}\" not found.`);\n\t}\n}\n","import kleur from \"kleur\";\nimport npx from \"libnpx\";\nimport { createRequire } from \"node:module\";\nimport path from \"node:path\";\nimport which from \"which\";\n\nimport { NPX_RESOLVER_QUIET } from \"../constants\";\nimport { mrmDebug } from \"./utils\";\n\n/**\n * Resolve a module on-the-fly using npx under the hood\n */\nexport async function resolveUsingNpx(packageName: string): Promise<string> {\n\tconst debug = mrmDebug.extend(\"npxResolver\");\n\tconst npm = await which(\"npm\");\n\n\tdebug(`ensure packages: %s`, kleur.bold().cyan(packageName));\n\tconst { prefix } = await npx._ensurePackages(packageName, {\n\t\tnpm,\n\t\tq: NPX_RESOLVER_QUIET,\n\t});\n\n\tdebug(`temp dir: %s`, kleur.yellow(prefix));\n\n\t// const require = createRequire(import.meta.url);\n\tconst resolved = require.resolve(packageName, {\n\t\tpaths: [\n\t\t\tpath.join(prefix, \"lib\", \"node_modules\"),\n\t\t\tpath.join(prefix, \"lib64\", \"node_modules\"),\n\t\t],\n\t});\n\n\tif (!resolved) {\n\t\tthrow Error(`npx failed resolving ${packageName}`);\n\t}\n\n\tdebug(`resolved: %s`, kleur.yellow(resolved));\n\n\treturn resolved;\n}\n","import { lstat } from \"node:fs/promises\";\nimport { createRequire } from \"node:module\";\nimport path from \"node:path\";\n\nimport { resolveUsingNpx } from \"./npxResolver\";\nimport { promiseFirst } from \"./promises\";\nimport { getPackageName, printError } from \"./utils\";\n\n/**\n * Resolve a set of directories using npx\n */\nexport async function resolveDirectories(\n\tpaths: string[],\n\tpreset: string,\n\tcustomDir?: string\n): Promise<string[]> {\n\t// Custom config / tasks directory\n\tif (customDir) {\n\t\tconst resolvedDir = path.resolve(customDir);\n\t\tconst stat = await lstat(resolvedDir);\n\n\t\tif (stat.isDirectory()) {\n\t\t\tprintError(`Directory \"${resolvedDir}\" not found.`);\n\t\t\tprocess.exit(1);\n\t\t}\n\n\t\tpaths.unshift(resolvedDir);\n\t}\n\n\t// const require = createRequire(import.meta.url);\n\tconst presetPackageName = getPackageName(\"preset\", preset);\n\ttry {\n\t\tconst presetPath = await promiseFirst([\n\t\t\t() => require.resolve(presetPackageName),\n\t\t\t() => require.resolve(preset),\n\t\t\t() => resolveUsingNpx(presetPackageName),\n\t\t\t() => resolveUsingNpx(preset),\n\t\t]);\n\t\treturn [...paths, path.dirname(presetPath)];\n\t} catch {\n\t\tprintError(`Preset \"${preset}\" not found.\n\nWe've tried to load \"${presetPackageName}\" and \"${preset}\" npm packages.`);\n\t\tprocess.exit(1);\n\t}\n}\n","import glob from \"glob\";\nimport kleur from \"kleur\";\nimport path from \"node:path\";\n\nimport type { MrmOptions, TaskRecords } from \"../types/mrm\";\nimport { mrmDebug } from \"./utils\";\n\n/**\n * Return all task and alias names and descriptions from all search directories.\n */\nexport async function getAllTasks(\n\tdirectories: string[],\n\toptions: MrmOptions\n): Promise<TaskRecords> {\n\tconst debug = mrmDebug.extend(\"getAllTasks\");\n\tconst allTasks: TaskRecords = options.aliases ?? ({} as TaskRecords);\n\n\tdebug(\"searching dirs: %O\", directories);\n\n\tfor (const dir of directories) {\n\t\tdebug(\"entering: %s\", kleur.yellow(dir));\n\n\t\tconst tasks = glob.sync(`${dir}/*/index.js`);\n\t\tconsole.error(tasks);\n\n\t\tdebug(\"\\\\ task count: %s\", kleur.yellow(tasks.length));\n\n\t\tfor (const filename of tasks) {\n\t\t\tconst taskName = path.basename(path.dirname(filename));\n\n\t\t\tdebug(\" | %s\", kleur.green(taskName));\n\n\t\t\tif (!allTasks[taskName]) {\n\t\t\t\tconst module = await import(filename);\n\t\t\t\tallTasks[taskName] = module.description || \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn allTasks;\n}\n","import inquirer from \"inquirer\";\nimport kleur from \"kleur\";\nimport { createRequire } from \"node:module\";\n\nimport type { CliArgs, MrmOptions, MrmTask } from \"../types/mrm\";\nimport {\n\tMrmInvalidTask,\n\tMrmUndefinedOption,\n\tMrmUnknownAlias,\n\tMrmUnknownTask,\n} from \"./errors\";\nimport { resolveUsingNpx } from \"./npxResolver\";\nimport { promiseFirst, promiseSeries } from \"./promises\";\nimport { getAllAliases, getPackageName, mrmDebug, tryFile } from \"./utils\";\n\nconst debug = mrmDebug.extend(\"taskRunner\");\n\n/**\n * Run a single or list of tasks.\n */\nexport async function run(\n\tname: string | string[],\n\tdirectories: string[],\n\toptions: MrmOptions,\n\targv: CliArgs\n): Promise<unknown> {\n\tconst taskList = [name].flat();\n\tconst aliases = options.aliases;\n\n\tdebug(\"tasks to run: %O\", taskList);\n\tdebug(\"aliases: %O\", aliases);\n\n\treturn promiseSeries(taskList, async taskName => {\n\t\tif (aliases && Object.hasOwn(aliases, taskName)) {\n\t\t\treturn await runAlias(taskName, directories, options, argv);\n\t\t}\n\n\t\treturn await runTask(taskName, directories, options, argv);\n\t});\n}\n\n/**\n * Run an alias.\n */\nasync function runAlias(\n\taliasName: string,\n\tdirectories: string[],\n\toptions: MrmOptions,\n\targv: CliArgs\n): Promise<unknown> {\n\tconst tasks = getAllAliases(options)[aliasName];\n\n\tif (!tasks) {\n\t\tthrow new MrmUnknownAlias(`Alias \"${aliasName}\" not found.`);\n\t}\n\n\tif (!argv.silent || !mrmDebug.enabled) {\n\t\tconsole.log(kleur.yellow(`Running alias ${aliasName}...`));\n\t}\n\n\tdebug(\"running alias: %s\", kleur.bgMagenta().white(aliasName));\n\n\treturn run(tasks, directories, options, argv);\n}\n\n/**\n * Run a task.\n */\nasync function runTask(\n\ttaskName: string,\n\tdirectories: string[],\n\toptions: MrmOptions,\n\targv: CliArgs\n): Promise<unknown> {\n\tdebug(\"running task: %s\", kleur.bgBlue().white(taskName));\n\n\tconst taskPackageName = getPackageName(\"task\", taskName);\n\n\t// const require = createRequire(import.meta.url);\n\tconst modulePath = await promiseFirst([\n\t\t() => tryFile(`${taskName}/index.js`, directories),\n\t\t() => require.resolve(taskPackageName),\n\t\t() => resolveUsingNpx(taskPackageName),\n\t\t() => require.resolve(taskName),\n\t\t() => resolveUsingNpx(taskName),\n\t]);\n\n\tif (!modulePath) {\n\t\tthrow new MrmUnknownTask(`Task \"${taskName}\" not found.`, {\n\t\t\ttaskName,\n\t\t});\n\t}\n\n\t// replacing require()\n\tconst module = (await import(modulePath)).default as MrmTask;\n\n\tdebug(\"imported: %O\", module);\n\n\tif (typeof module !== \"function\") {\n\t\tthrow new MrmInvalidTask(`Cannot call task \"${taskName}\".`, { taskName });\n\t}\n\n\tif (!argv.silent || !mrmDebug.enabled) {\n\t\tconsole.log(kleur.cyan(`Running ${taskName}...`));\n\t}\n\n\t// Gather the task's options\n\tconst config = await getTaskOptions(module, argv.interactive, options);\n\tdebug(\"task config: %O\", config);\n\n\t// Run the task\n\treturn module(config, argv);\n}\n\n/**\n * Get task specific options, either by running Inquirer.js in interactive mode,\n * or using defaults.\n */\nasync function getTaskOptions(\n\ttask: MrmTask,\n\tinteractive = false,\n\toptions: Partial<MrmOptions> = {}\n): Promise<Partial<MrmOptions>> {\n\t// If no parameters set, resolve to default options (from config file or command line).\n\tif (!task.parameters) {\n\t\treturn options;\n\t}\n\n\tconst parameters = Object.entries(task.parameters);\n\n\tconst allOptions = await Promise.all(\n\t\tparameters.map(async ([name, param]) => ({\n\t\t\t...param,\n\t\t\tname,\n\t\t\tdefault:\n\t\t\t\t// Merge available default options with parameter initial values\n\t\t\t\ttypeof options[name] !== \"undefined\"\n\t\t\t\t\t? options[name]\n\t\t\t\t\t: typeof param.default === \"function\"\n\t\t\t\t\t? await param.default(options)\n\t\t\t\t\t: param.default,\n\t\t}))\n\t);\n\n\t// Split interactive and static options\n\tconst prompts = allOptions.filter(\n\t\toption => interactive && option.type !== \"config\"\n\t);\n\tconst statics = allOptions.filter(i => prompts.indexOf(i) > -1);\n\n\t// Validate static options\n\tconst invalid = statics.filter(param =>\n\t\tparam.validate ? param.validate(param.default) !== true : false\n\t);\n\n\tif (invalid.length > 0) {\n\t\tconst names = invalid.map(({ name }) => name);\n\t\tthrow new MrmUndefinedOption(\n\t\t\t`Missing required config options: ${names.join(\", \")}.`,\n\t\t\t{\n\t\t\t\tunknown: names,\n\t\t\t}\n\t\t);\n\t}\n\n\t// Run Inquirer.js with interactive options\n\tconst answers = prompts.length > 0 ? await inquirer.prompt(prompts) : {};\n\n\t// Merge answers with static defaults\n\tconst values: Partial<MrmOptions> = { ...answers };\n\n\tfor (const param of statics) {\n\t\tvalues[param.name] = param.default;\n\t}\n\n\treturn values;\n}\n","import type { Debugger } from \"debug\";\nimport glob from \"glob\";\nimport inquirer from \"inquirer\";\nimport kleur from \"kleur\";\nimport * as mrmCore from \"mrm-core\";\nimport { createRequire } from \"node:module\";\nimport { homedir } from \"node:os\";\nimport path from \"node:path\";\n\nimport {\n\tgetPackageName,\n\tisDirSync,\n\tmrmDebug,\n\tMrmInvalidTask,\n\tMrmPathNotExist,\n\tMrmUndefinedOption,\n\tMrmUnknownAlias,\n\tMrmUnknownTask,\n\tpromiseFirst,\n\tpromiseSeries,\n\tresolveDirectories,\n\tresolveUsingNpx,\n\ttryFile,\n} from \"./lib\";\nimport type { CliArgs, MrmOptions, MrmTask, TaskRecords } from \"./types/mrm\";\n\n// const require = createRequire(import.meta.url);\n\nexport class TaskStore {\n\tpreset = \"default\";\n\tinitialized = false;\n\n\tget PATH(): string[] {\n\t\treturn this._directories;\n\t}\n\n\tget options() {\n\t\treturn this._options;\n\t}\n\n\tget aliases(): TaskRecords {\n\t\treturn this._options.aliases ?? {};\n\t}\n\n\tget isDefaultPreset(): boolean {\n\t\treturn this.preset === \"default\";\n\t}\n\n\tstatic DEFAULT_DIRECTORIES = [\n\t\tpath.resolve(homedir(), \"dotfiles/mrm\"),\n\t\tpath.resolve(homedir(), \".mrm\"),\n\t];\n\n\tprivate _argv: CliArgs;\n\tprivate _debug: Debugger;\n\tprivate _directories: string[] = [];\n\tprivate _options: Partial<MrmOptions> = {};\n\n\t/**\n\t * Build a new instance of the TaskStore\n\t */\n\tconstructor(argv: CliArgs, options?: MrmOptions) {\n\t\tthis._debug = mrmDebug.extend(\"TaskStore\");\n\n\t\tthis._argv = argv;\n\t\tthis._options = options ?? {};\n\n\t\tconst { preset } = this._argv;\n\n\t\tif (preset) {\n\t\t\tthis._debug(\"activating preset: %s\", preset);\n\t\t\tthis.preset = preset;\n\t\t}\n\t}\n\n\t/**\n\t * This needs to be called before the store is used, otherwise npx will\n\t * not have a chance to ensure the default preset is available.\n\t */\n\tasync initStore(directories?: string[]): Promise<void> {\n\t\tthis._directories = await resolveDirectories(\n\t\t\tdirectories ?? TaskStore.DEFAULT_DIRECTORIES,\n\t\t\t\"default\",\n\t\t\tthis._argv.dir\n\t\t);\n\t\tthis.initialized = true;\n\t}\n\n\t/**\n\t * Add a new directory to the search PATH.\n\t */\n\taddDirToPath(dir: string) {\n\t\tif (!isDirSync(dir)) {\n\t\t\tthrow new MrmPathNotExist(`Could not resolve the given path: ${dir}`);\n\t\t}\n\t\tthis._directories.push(dir);\n\t}\n\n\t/**\n\t * Try to find a file in the PATH.\n\t */\n\t// async find(filename: string): Promise<string> {\n\t// \treturn await tryFile(filename, this.PATH);\n\t// }\n\n\tsetOption(option: string, value: unknown) {\n\t\tthis._options[option] = value;\n\t}\n\n\tsetOptions(options: Partial<MrmOptions>) {\n\t\tthis._options = options;\n\t}\n\n\tmergeOptions(options: Partial<MrmOptions>) {\n\t\tthis._options = {\n\t\t\t...this._options,\n\t\t\t...options,\n\t\t};\n\t}\n\n\t/**\n\t * Gather all of the available tasks from the tasks PATH.\n\t */\n\tasync getAllTasks(): Promise<TaskRecords> {\n\t\tconst allTasks: TaskRecords = this.aliases;\n\n\t\tthis._debug(\"PATH: %O\", this.PATH);\n\n\t\tfor (const dir of this.PATH) {\n\t\t\tthis._debug(\"entering: %s\", kleur.yellow(dir));\n\n\t\t\tconst tasks = glob.sync(`${dir}/*/index.js`);\n\t\t\tconsole.error(tasks);\n\n\t\t\tthis._debug(\"\\\\ task count: %s\", kleur.yellow(tasks.length));\n\n\t\t\tfor (const filename of tasks) {\n\t\t\t\tconst taskName = path.basename(path.dirname(filename));\n\n\t\t\t\tthis._debug(\" | %s\", kleur.green(taskName));\n\n\t\t\t\tif (!allTasks[taskName]) {\n\t\t\t\t\tconst module = await import(filename);\n\t\t\t\t\tallTasks[taskName] = module.description || \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn allTasks;\n\t}\n\n\t/**\n\t * Run a single or list of tasks.\n\t */\n\tasync run(name: string | string[]): Promise<unknown> {\n\t\tif (!this.initialized) {\n\t\t\tthrow new Error(\n\t\t\t\t`TaskStore is not initialized. The initStore() method must be called before run()`\n\t\t\t);\n\t\t}\n\n\t\t// ensure list processing even if one task\n\t\tconst taskList = [name].flat();\n\n\t\tthis._debug(\"tasks to run: %O\", taskList);\n\t\tthis._debug(\"aliases: %O\", this.aliases);\n\n\t\treturn await promiseSeries(taskList, async taskName => {\n\t\t\tif (Object.hasOwn(this.aliases, taskName)) {\n\t\t\t\treturn await this.runAlias(taskName);\n\t\t\t}\n\n\t\t\treturn await this.runTask(taskName);\n\t\t});\n\t}\n\n\t/**\n\t * Run an alias.\n\t */\n\tasync runAlias(aliasName: string): Promise<unknown> {\n\t\tif (Object.hasOwn(this.aliases, aliasName) === false) {\n\t\t\tthrow new MrmUnknownAlias(`Alias \"${aliasName}\" not found.`);\n\t\t}\n\n\t\tconst aliasedTasks = this.aliases[aliasName];\n\n\t\tif (!this._argv.silent || !this._debug.enabled) {\n\t\t\tconsole.log(kleur.yellow(`Running alias ${aliasName}...`));\n\t\t}\n\n\t\tthis._debug(\"running alias: %s\", kleur.bgMagenta().white(aliasName));\n\t\tthis._debug(\"mapped tasks: %O\", aliasedTasks);\n\n\t\treturn await this.run(aliasedTasks);\n\t}\n\n\t/**\n\t * Run a task.\n\t */\n\tasync runTask(taskName: string): Promise<unknown> {\n\t\tthis._debug(\"running task: %s\", kleur.bgBlue().white(taskName));\n\n\t\tconst modulePath = await this.resolveTask(taskName);\n\n\t\tif (!modulePath) {\n\t\t\tthrow new MrmUnknownTask(`Task \"${taskName}\" not found.`, {\n\t\t\t\ttaskName,\n\t\t\t});\n\t\t}\n\n\t\t// replacing require()\n\t\tconst module = (await import(modulePath)).default as MrmTask;\n\n\t\tif (typeof module !== \"function\") {\n\t\t\tthrow new MrmInvalidTask(`Cannot call task \"${taskName}\".`, { taskName });\n\t\t}\n\n\t\tif (!this._argv.silent || !this._debug.enabled) {\n\t\t\tconsole.log(kleur.cyan(`Running ${taskName}...`));\n\t\t}\n\n\t\t// Gather the task's options\n\t\tconst config = await this.getTaskOptions(module, this._argv.interactive);\n\n\t\tif (this._argv[\"examine\"]) {\n\t\t\t// Dump details if inspecting\n\t\t\tconsole.log(kleur.underline(`\\nDetails for Task \"${taskName}\"`));\n\t\t\tconsole.log(`\\nModule: `, String(module));\n\t\t\tconsole.log(`\\nConfig: `, config);\n\t\t\tconsole.log(`\\nCLI Args: `, this._argv);\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (this._argv[\"useNewTaskSignature\"]) {\n\t\t\t\t// Run the task, now with `mrm-core` injected to the task\n\t\t\t\treturn module({ config, argv: this._argv, mrmCore });\n\t\t\t} else {\n\t\t\t\t// The original method of calling tasks\n\t\t\t\treturn module(config, this._argv);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get task specific options, either by running Inquirer.js in interactive mode,\n\t * or using defaults.\n\t */\n\tasync getTaskOptions(\n\t\ttask: MrmTask,\n\t\tinteractive = false\n\t): Promise<Partial<MrmOptions>> {\n\t\t// If no parameters set, resolve to default options (from config file or command line).\n\t\tif (!task.parameters) {\n\t\t\treturn this._options;\n\t\t}\n\n\t\tconst parameters = Object.entries(task.parameters);\n\n\t\tconst allOptions = await Promise.all(\n\t\t\tparameters.map(async ([name, param]) => ({\n\t\t\t\t...param,\n\t\t\t\tname,\n\t\t\t\tdefault:\n\t\t\t\t\t// Merge available default options with parameter initial values\n\t\t\t\t\ttypeof this._options[name] !== \"undefined\"\n\t\t\t\t\t\t? this._options[name]\n\t\t\t\t\t\t: typeof param.default === \"function\"\n\t\t\t\t\t\t? await param.default(this._options)\n\t\t\t\t\t\t: param.default,\n\t\t\t}))\n\t\t);\n\n\t\t// Split interactive and static options\n\t\tconst prompts = allOptions.filter(\n\t\t\toption => interactive && option.type !== \"config\"\n\t\t);\n\t\tconst statics = allOptions.filter(i => prompts.indexOf(i) > -1);\n\n\t\t// Validate static options\n\t\tconst invalid = statics.filter(param =>\n\t\t\tparam.validate ? param.validate(param.default) !== true : false\n\t\t);\n\n\t\tif (invalid.length > 0) {\n\t\t\tconst names = invalid.map(({ name }) => name);\n\t\t\tthrow new MrmUndefinedOption(\n\t\t\t\t`Missing required config options: ${names.join(\", \")}.`,\n\t\t\t\t{\n\t\t\t\t\tunknown: names,\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t// Run Inquirer.js with interactive options\n\t\tconst answers = prompts.length > 0 ? await inquirer.prompt(prompts) : {};\n\n\t\t// Merge answers with static defaults\n\t\tconst values: Partial<MrmOptions> = { ...answers };\n\n\t\tfor (const param of statics) {\n\t\t\tvalues[param.name] = param.default;\n\t\t}\n\n\t\treturn values;\n\t}\n\n\t// async *getFiles(dir: string): AsyncGenerator<string> {\n\t// \tconst dirents = await readdir(dir, { withFileTypes: true });\n\t// \tfor (const dirent of dirents) {\n\t// \t\tconst res = resolve(dir, dirent.name);\n\t// \t\tif (dirent.isDirectory()) {\n\t// \t\t\tyield* this.getFiles(res);\n\t// \t\t} else {\n\t// \t\t\tyield res;\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t/**\n\t * @TODO [feat] Queue tasks to run?\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tqueueTasks(task: string | string[]) {\n\t\t//\n\t}\n\n\t/**\n\t * @TODO [feat] Queue tasks to run?\n\t */\n\tasync runTaskQueue() {\n\t\t//\n\t}\n\n\t/**\n\t * Given a task name, try to resolve with all available methods.\n\t */\n\tprivate async resolveTask(taskName: string): Promise<null | string> {\n\t\tconst tracer = this._debug.extend(\"resolveTask\");\n\n\t\tconst taskPackageName = getPackageName(\"task\", taskName);\n\n\t\ttry {\n\t\t\treturn await promiseFirst([\n\t\t\t\t() => {\n\t\t\t\t\ttracer(\"tryFile(%s)\", taskName);\n\t\t\t\t\treturn tryFile(`${taskName}/index.js`, this.PATH);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\ttracer(`require.resolve(%s)`, taskPackageName);\n\t\t\t\t\treturn require.resolve(taskPackageName);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\ttracer(`resolveUsingNpx(%s)`, taskPackageName);\n\t\t\t\t\treturn resolveUsingNpx(taskPackageName);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\ttracer(`require.resolve(%s)`, taskName);\n\t\t\t\t\treturn require.resolve(taskName);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\ttracer(`resolveUsingNpx(%s)`, taskName);\n\t\t\t\t\treturn resolveUsingNpx(taskName);\n\t\t\t\t},\n\t\t\t]);\n\t\t} catch {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n"],"mappings":"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","names":["import_kleur","kleur","envPaths","import_promises","import_kleur","import_kleur","Debug","path","kleur","debug","kleur","path","fs","kleur","import_kleur","import_promises","import_node_path","import_kleur","import_node_path","import_which","debug","which","kleur","npx","path","import_promises","import_node_path","path","import_kleur","import_node_path","import_kleur","debug","import_glob","import_inquirer","import_kleur","import_node_path","kleur","glob","path","module","inquirer","debug","minimist","kleur","updateNotifier","packageJson","_a"]}